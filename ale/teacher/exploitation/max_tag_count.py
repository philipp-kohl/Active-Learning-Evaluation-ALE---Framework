import random
from abc import ABC
from typing import List, Dict, Optional, Tuple
from ale.config import NLPTask
from ale.corpus.corpus import Corpus
from ale.registry.registerable_teacher import TeacherRegistry
from ale.teacher.base_teacher import BaseTeacher
from ale.teacher.exploitation.aggregation_methods import AggregationMethod
from ale.trainer.predictor import Predictor
from ale.trainer.prediction_result import TokenConfidence, PredictionResult
from ale.teacher.teacher_utils import is_named_entity


@TeacherRegistry.register("max-tag-count")
class MaxTagCountTeacher(BaseTeacher, ABC):
    """
    Max Tag Count teacher: chooses documents where most tokens are predicted to be (part of) named entities

        Applied to ER task:
        - aggregation by sum: 
            - Esuli, A., Marcheggiani, D., Sebastiani, F.: Sentence-based active learning strategies for 
            information extraction. In: CEUR Workshop Proceedings. vol. 560, pp. 41â€“45 (2010)
    """

    def __init__(
            self,
            corpus: Corpus,
            predictor: Predictor,
            seed: int,
            labels: List[any],
            nlp_task: NLPTask,
            # Used to compute an instance score based on the token-wise determination if a NE was predicted.
            # Publication used the sum operation for this.
            aggregation_method: Optional[AggregationMethod] = AggregationMethod.SUM
    ):
        super().__init__(
            corpus=corpus,
            predictor=predictor,
            seed=seed,
            labels=labels,
            nlp_task=nlp_task,
            aggregation_method=aggregation_method
        )
        random.seed(self.seed)

    def propose(self, potential_ids: List[int], step_size: int, budget: int) -> List[int]:
        if budget < len(potential_ids):
            batch: List[int] = random.sample(potential_ids, budget)
        else:
            batch: List[int] = potential_ids
        idx2text = self.corpus.get_text_by_ids(batch)
        prediction_results: Dict[int, PredictionResult] = self.predictor.predict(idx2text)
        out_ids: List[int] = self.compute_function(prediction_results, step_size)

        return out_ids

    def compute_ner(self, predictions: Dict[int, PredictionResult], step_size: int) -> List[int]:
        """
        Max tag count is calculated on token-level and aggregated on instance-level as configured.
        """
        scores = dict()
        for idx, prediction in predictions.items():
            token_confidences: List[TokenConfidence] = prediction.ner_confidences_token
            count_token_nes: List[float] = []
            for token in token_confidences:
                probable_label: str = token.get_predicted_label()
                if is_named_entity(probable_label):
                    count_token_nes.append(1)
                else:
                    count_token_nes.append(0)
            instance_score = self.aggregate_function(count_token_nes)
            scores[idx] = instance_score
        sorted_dict_by_score: List[Tuple[int, int]] = sorted(scores.items(), key=lambda x: x[1], reverse=True)
        out_ids = [item[0] for item in sorted_dict_by_score[:step_size]]

        return out_ids

    def compute_cls(self, predictions: Dict[int, PredictionResult], step_size: int) -> List[int]:
        raise NotImplementedError(
            "Max Tag Count teacher is not implemented for text classification yet.")
