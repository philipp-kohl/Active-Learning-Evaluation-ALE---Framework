from enum import Enum
from typing import Callable, Tuple, Dict, Optional, List
import numpy as np
from ale.trainer.prediction_result import PredictionResult, Span

class AGGREGATION_METHOD(str, Enum):
    AVERAGE = "AVG"
    STD = "STD"
    MAXIMUM = "MAX"
    MINIMUM = "MIN"
    SUM = "SUM"

class Aggregation:
    """
    Aggregation of several prediction results on token level to generate a score for the whole document.
    Needed for exploitation approaches in entity recognition.
    """
    def __init__(self, aggregation_method: AGGREGATION_METHOD):
            """
            Returns:
                - aggregation_function
            """
            self.aggregate_function: Callable[
                [List[float]], Tuple[Dict[str, float], Dict[str, float], Dict[str, float], Dict[str, float], Dict[str, float]]] = {
                AGGREGATION_METHOD.AVERAGE: Aggregation.calculate_average,
                AGGREGATION_METHOD.STD: Aggregation.calculate_std,
                AGGREGATION_METHOD.MAXIMUM: Aggregation.calculate_maximum,
                AGGREGATION_METHOD.MINIMUM: Aggregation.calculate_minimum,
                AGGREGATION_METHOD.SUM: Aggregation.calculate_sum
            }[aggregation_method]

    def get_aggregate_function(self):
        return self.aggregate_function

    def calculate_average(predictions: List[float]) -> float:
        return np.average(predictions)
    
    def calculate_std(predictions: List[float]) -> float:
        return np.std(predictions) 

    def calculate_maximum(predictions: List[float]) -> float:
        return max(predictions)    

    def calculate_minimum(predictions: List[float]) -> float:
        return min(predictions) 

    def calculate_sum(predictions: List[float]) -> float:
        return sum(predictions) 