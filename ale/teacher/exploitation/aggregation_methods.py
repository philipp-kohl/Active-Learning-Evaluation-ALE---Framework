from enum import Enum
from typing import Callable, Tuple, Dict, Optional, List
import numpy as np
from ale.trainer.prediction_result import PredictionResult, Span


class AggregationMethod(str, Enum):
    AVERAGE = "AVG"
    STD = "STD"
    MAXIMUM = "MAX"
    MINIMUM = "MIN"
    SUM = "SUM"


class Aggregation:
    """
    Aggregation of several prediction results on token level to generate a score for the whole document.
    Needed for exploitation approaches in entity recognition.
    """
    def __init__(self, aggregation_method: AggregationMethod):
            """
            Returns:
                - aggregation_function
            """
            self.aggregate_function: Callable[
                [List[float]], float] = {
                AggregationMethod.AVERAGE: Aggregation.calculate_average,
                AggregationMethod.STD: Aggregation.calculate_std,
                AggregationMethod.MAXIMUM: Aggregation.calculate_maximum,
                AggregationMethod.MINIMUM: Aggregation.calculate_minimum,
                AggregationMethod.SUM: Aggregation.calculate_sum
            }[aggregation_method]

    def get_aggregate_function(self):
        return self.aggregate_function

    @staticmethod
    def calculate_average(predictions: List[float]) -> float:
        return np.average(predictions)

    @staticmethod
    def calculate_std(predictions: List[float]) -> float:
        return np.std(predictions)

    @staticmethod
    def calculate_maximum(predictions: List[float]) -> float:
        return max(predictions)

    @staticmethod
    def calculate_minimum(predictions: List[float]) -> float:
        return min(predictions)

    @staticmethod
    def calculate_sum(predictions: List[float]) -> float:
        return sum(predictions)
