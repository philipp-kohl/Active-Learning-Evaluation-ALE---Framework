from enum import Enum
from typing import Callable, Tuple, Dict, Optional
import numpy as np
from ale.trainer.prediction_result import PredictionResult, Span

class AGGREGATION_METHOD(str, Enum):
    AVERAGE = "AVG"
    STD = "STD"
    MAXIMUM = "MAX"
    MINIMUM = "MIN"
    SUM = "SUM"

class Aggregation:
    """
    Aggregation of several prediction results on token level to generate a score for the whole document.
    Needed for exploitation approaches in entity recognition.
    """
    def __init__(aggregation_method: AGGREGATION_METHOD):
            """
            Returns:
                - aggregation_function
            """
            aggregate_function: Callable[
                [PredictionResult], Tuple[Dict[str, float], Dict[str, float], Dict[str, float], Dict[str, float], Dict[str, float]]] = {
                AGGREGATION_METHOD.AVERAGE: Aggregation.calculate_average,
                AGGREGATION_METHOD.NORMED_STD: Aggregation.calculate_std,
                AGGREGATION_METHOD.MAXIMUM: Aggregation.calculate_maximum,
                AGGREGATION_METHOD.MINIMUM: Aggregation.calculate_minimum,
                AGGREGATION_METHOD.SUM: Aggregation.calculate_sum
            }[aggregation_method]

            return aggregate_function


    def calculate_average(prediction: PredictionResult) -> float:
        ner_confidences: Optional[Dict[Span, float]] = prediction.ner_confidences
        return np.average(ner_confidences.values())
    
    def calculate_std(prediction: PredictionResult) -> float:
        ner_confidences: Optional[Dict[Span, float]] = prediction.ner_confidences
        return np.std(ner_confidences.values()) 

    def calculate_maximum(prediction: PredictionResult) -> float:
        ner_confidences: Optional[Dict[Span, float]] = prediction.ner_confidences
        return max(ner_confidences.values())    

    def calculate_minimum(prediction: PredictionResult) -> float:
        ner_confidences: Optional[Dict[Span, float]] = prediction.ner_confidences
        return min(ner_confidences.values()) 

    def calculate_sum(prediction: PredictionResult) -> float:
        ner_confidences: Optional[Dict[Span, float]] = prediction.ner_confidences
        return sum(ner_confidences.values()) 